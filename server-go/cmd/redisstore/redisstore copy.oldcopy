package redisstore

import (
	//"bytes"
	"context"
	"crypto/rand"
	"encoding/base32"
	//	"encoding/gob"
	"encoding/json"
	"errors"
	"io"
	"log"

	//"log"
	"net/http"
	//"net/url"
	"strings"
	"time"

	"github.com/go-redis/redis/v8"
	"github.com/gorilla/sessions"
)

type SessionKey string

// RedisStore stores gorilla sessions in Redis
type RedisStore struct {
	// client to connect to redis
	client redis.UniversalClient
	// default options to use when a new session is created
	options sessions.Options
	// key prefix with which the session will be stored
	keyPrefix string
	// key generator
	keyGen KeyGenFunc
	// session serializer
	serializer SessionSerializer
}

// KeyGenFunc defines a function used by store to generate a key
type KeyGenFunc func() (string, error)
type JsonSerializer struct{}

// NewRedisStore returns a new RedisStore with default configuration
func NewRedisStore(ctx context.Context, client redis.UniversalClient) (*RedisStore, error) {
	rs := &RedisStore{
		options: sessions.Options{
			Path:     "/",
			Secure:   true,
			HttpOnly: true,
			MaxAge:   1 * 60 * 1000, // 86400 * 30, // TODO мы как бы не должны создавать Cookie тут
		},
		client:     client,
		keyPrefix:  "session:",
		keyGen:     generateRandomKey,
		serializer: JsonSerializer{},
	}

	return rs, rs.client.Ping(ctx).Err()
}

// Get возвращает сеанс для данного имени после его добавления в реестр.
func (s *RedisStore) Get(r *http.Request, name string) (*sessions.Session, error) {
	// GetRegistry возвращает экземпляр реестра для текущего запроса.
	// Get регистрирует и возвращает сеанс для заданного имени и хранилища сеансов.
	// Возвращает новую сессию, если для этого имени не зарегистрировано ни одной сессии.
	// вызывается  s store.New(req,name)
	sess, err := sessions.GetRegistry(r).Get(s, name) // TODO Пересмотреть добавление если нет.... и что там ваще
	sess.ID = checkIdSession(sess.ID)                 // наш код из куки
	return sess, err
}

// New возвращает сеанс для заданного имени без добавления его в реестр..
func (s *RedisStore) New(r *http.Request, name string) (*sessions.Session, error) {
	session := sessions.NewSession(s, name) // имя Cookie
	opts := s.options
	session.Options = &opts
	session.IsNew = true

	c, err := r.Cookie(name)
	if err != nil {
		return session, nil
	}
	session.ID = checkIdSession(c.Value)
	err = s.load(r.Context(), session) // попытаемся найти в Redis что-нибудь
	if err == nil {
		session.IsNew = false
	} else if err == redis.Nil { // Nil ключ не существует
		err = nil // нет данных в Redis
	}
	return session, err
}

// Сохранить добавляет к ответу один сеанс.
//
// Если Options.MaxAge сеанса <= 0, то файл сеанса будет
// удалено из магазина. С помощью этого процесса он обеспечивает правильное
// обработка файлов cookie сеанса, поэтому не нужно доверять управлению файлами cookie в
// веб-браузер.
func (s *RedisStore) Save(r *http.Request, w http.ResponseWriter, session *sessions.Session) error {
	// Delete if max-age is <= 0
	if session.Options.MaxAge <= 0 {
		if err := s.delete(r.Context(), session); err != nil {
			return err
		}
		http.SetCookie(w, sessions.NewCookie(session.Name(), "", session.Options))
		return nil
	}

	if session.ID == "" {
		id, err := s.keyGen()
		if err != nil {
			return errors.New("redisstore: не удалось сгенерировать идентификатор сеанса")
		}
		session.ID = id
	}
	if err := s.save(r.Context(), session); err != nil {
		return err
	}

	http.SetCookie(w, sessions.NewCookie(session.Name(), session.ID, session.Options))
	return nil
}

// Options set options to use when a new session is created
func (s *RedisStore) Options(opts sessions.Options) {
	s.options = opts
}

// KeyPrefix sets the key prefix to store session in Redis
func (s *RedisStore) KeyPrefix(keyPrefix string) {
	s.keyPrefix = keyPrefix
}

// KeyGen sets the key generator function
func (s *RedisStore) KeyGen(f KeyGenFunc) {
	s.keyGen = f
}

// Serializer sets the session serializer to store session
func (s *RedisStore) Serializer(ss SessionSerializer) {
	s.serializer = ss
}

// Close closes the Redis store
func (s *RedisStore) Close() error {
	return s.client.Close()
}

// save writes session in Redis
func (s *RedisStore) save(ctx context.Context, session *sessions.Session) error {

	b, err := s.serializer.Serialize(session)
	if err != nil {
		return err
	}
	// необходимо подписать ID
	log.Println("save session, id", s.keyPrefix+session.ID)
	return s.client.Set(ctx, s.keyPrefix+session.ID, string(b), time.Duration(session.Options.MaxAge)*time.Second).Err()
}

// load reads session from Redis
func (s *RedisStore) load(ctx context.Context, session *sessions.Session) error {

	cmd := s.client.Get(ctx, s.keyPrefix+session.ID)
	if cmd.Err() != nil {
		return cmd.Err()
	}

	b, err := cmd.Bytes() // получим значение Redis = Json-string
	if err != nil {
		return err
	}
	return s.serializer.Deserialize(b, session)
}

// delete deletes session in Redis
func (s *RedisStore) delete(ctx context.Context, session *sessions.Session) error {
	return s.client.Del(ctx, s.keyPrefix+session.ID).Err()
}

// SessionSerializer provides an interface for serialize/deserialize a session
type SessionSerializer interface {
	Serialize(s *sessions.Session) ([]byte, error)
	Deserialize(b []byte, s *sessions.Session) error
}

func (gs JsonSerializer) Serialize(s *sessions.Session) ([]byte, error) {
	// нашу структуру в Json - чтоб ее понимал Express Session
	if data, ok := s.Values["Data"].(SessionJson); ok {

		b, er := json.Marshal(data)
		if er != nil {
			log.Println("error:", er)
		}
		s.Options.MaxAge = data.Cookie.OriginalMaxAge // возьмем из наших настроек из JS
		log.Println("str:", string(b))
		return b, nil
	}
	return nil, errors.New("не удалось преобразовать сессию для Redis")
}

func (gs JsonSerializer) Deserialize(d []byte, s *sessions.Session) error {
	m := SessionJson{}           // наша структура
	err := json.Unmarshal(d, &m) // Засунем в структуру
	if err != nil {
		log.Println("error:", err)
	}
	s.Values["Data"] = m // структуру в сессию, плохо понимаю зачем.

	return nil
}

// generate RandomKey returns a new random key
func generateRandomKey() (string, error) {
	k := make([]byte, 64)
	if _, err := io.ReadFull(rand.Reader, k); err != nil {
		return "", err
	}
	return strings.TrimRight(base32.StdEncoding.EncodeToString(k), "="), nil
}
